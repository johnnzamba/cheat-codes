// Generated by CoffeeScript 2.5.1
(function() {
  var _, fs, lazy, path;

  fs = require('fs');

  path = require('path');

  lazy = require('lazy');

  _ = require('underscore');

  exports.WordGenerator = (function() {
    var alphabet, tree;

    class WordGenerator {
      readWordsFile(callback, finished) {
        var filepath, input, readStream;
        filepath = path.join(__dirname, '../vendor/words.txt');
        readStream = fs.createReadStream(filepath);
        input = new lazy(readStream);
        input.lines.forEach(function(line) {
          return callback('' + line);
        });
        return readStream.on('end', function() {
          return finished();
        });
      }

      histogramify(word) {
        var histogram, ndx;
        histogram = {};
        ndx = 0;
        while (ndx < alphabet.length) {
          histogram[alphabet[ndx]] = 0;
          ndx++;
        }
        ndx = 0;
        while (ndx < word.length) {
          histogram[word[ndx]]++;
          ndx++;
        }
        return histogram;
      }

      generateTree(complete) {
        var self;
        console.log('Generating anagram tree...');
        self = this;
        // For each line in the file, this function is called
        return this.readWordsFile((function(word) {
          var curNode, freq, hist, letter, ndx;
          hist = self.histogramify(word);
          curNode = tree;
          ndx = 0;
          while (ndx < alphabet.length) {
            letter = alphabet[ndx];
            freq = hist[letter];
            if (curNode[freq] == null) {
              curNode[freq] = {};
            }
            curNode = curNode[freq];
            ndx++;
          }
          if (!curNode.words) {
            curNode.words = [];
          }
          return curNode.words.push(word);
        }), function() {
          console.log('Tree constructed. Ready for requests.');
          return complete();
        });
      }

      getAnagrams(lettersArray) {
        var allAnagrams, freq, frontier, hist, i, letter, ndx, newFrontier, node, nodeNdx, rootNode, wordNdx;
        hist = this.histogramify(lettersArray);
        rootNode = tree;
        frontier = [rootNode];
        ndx = 0;
        while (ndx < alphabet.length) {
          letter = alphabet[ndx];
          freq = hist[letter];
          newFrontier = [];
          nodeNdx = 0;
          while (nodeNdx < frontier.length) {
            node = frontier[nodeNdx];
            i = 0;
            while (i <= freq) {
              if (!!node[i]) {
                newFrontier.push(node[i]);
              }
              i++;
            }
            nodeNdx++;
          }
          frontier = newFrontier;
          ndx++;
        }
        allAnagrams = [];
        nodeNdx = 0;
        while (nodeNdx < frontier.length) {
          wordNdx = 0;
          while (wordNdx < frontier[nodeNdx].words.length) {
            allAnagrams.push(frontier[nodeNdx].words[wordNdx]);
            wordNdx++;
          }
          nodeNdx++;
        }
        return _.sortBy(allAnagrams, function(anagram) {
          return -anagram.length;
        });
      }

    };

    tree = {};

    alphabet = 'jqxzwkvfybhgmpudclotnraise';

    return WordGenerator;

  }).call(this);

}).call(this);
